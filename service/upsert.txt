const express = require('express');
const bodyParser = require('body-parser');
const { Pool } = require('pg');
const path = require('path');
const knex = require('knex');
const config = require('../knexfile');
const db = knex(config);
const app = express();
const router = express.Router();
const verifyAdminToken = require('../middleware/authorize');
const { validateBookData } = require('../routes/bookRouter');


function isValidBookTitle(title) {
  
  if (title === null || title === undefined) {
      return false;
  }

 
  if (typeof title !== 'string') {
      return false;
  }

  const trimmedTitle = title.trim();

  // Check if the trimmed title is not an empty string
  if (trimmedTitle === "") {
      return false;
  }

  const titleRegex = /^[A-Za-z0-9\s]+$/;
  // Test the input against the regular expression
  return titleRegex.test(trimmedTitle);
}



function isValidISBN(isbn) {
  // Check if the ISBN is not null, undefined, or an empty string
  if (isbn === null || isbn === undefined) {
      return false;
  }

  // Check if the ISBN is a string
  if (typeof isbn !== 'string') {
      return false;
  }

  // Trim the ISBN to remove leading and trailing whitespaces
  const trimmedISBN = isbn.trim();

  // Check if the trimmed ISBN is not an empty string
  if (trimmedISBN === "") {
      return false;
  }

  // Regular expression to allow only characters and numbers
  const isbnRegex = /^[A-Za-z0-9\s]+$/;

  // Test the input against the regular expression
  return isbnRegex.test(trimmedISBN);
}



    
function isValidName(name) {
  const nameRegex = /^[A-Za-z]+(?:[ -][A-Za-z]+)*$/;
  return nameRegex.test(name);
}




function isValidPrice(price) {
    
  if (typeof price !== 'number') {
    return false;
  }

  if (price < 0 || price >= 10000) {
    return false;
  }

  if (!/^\d+(\.\d{1,4})?$/.test(price.toString())) {
    return false;
  }

  return true;
}



function isValidPublicationDate(publicationDate) {
  // Split the date string into parts
  const parts = publicationDate.split('/');

  // Ensure that the date string has three parts (year, month, day)
  if (parts.length !== 3) {
    return false;
  }

  // Create a Date object
  const date = new Date(`${parts[0]}-${parts[1]}-${parts[2]}`);

  // Check if the conversion resulted in a valid date and the string is in the expected format
  return !isNaN(date) && date.toISOString().split('T')[0] === date.toISOString().split('T')[0];
}



router.post('/', verifyAdminToken ,  async (req, res) => {

    try {
      const validationErrors =[];
      let bookDataFromBody = req.body;
      console.log(bookDataFromBody.id);
      
      if (!req.body || Object.keys(req.body).length === 0) {
        return res.status(400).json({ error: 'Empty request body.Provide relavant information.' });
      }
      
      
        if(bookDataFromBody.id!= undefined) {
            const existingBook = await db('books').select('id').where('id', bookDataFromBody.id).first();
            console.log(existingBook);
              if(!existingBook){
                 return res.status(404).json('book does not exist.' );
              }
              if (Object.keys(req.body).length === 1 && req.body.hasOwnProperty('id')) {
                
           
            return res.status(200).json({ error: 'Update data does not contain any values to update..' });
            } 
            //if(bookDataFromBody.title){

           if(bookDataFromBody.Store){
            const storeExists = await db('bookstore').where('store', bookDataFromBody.Store).first();
        
            if (!storeExists) {
              validationErrors.push("Invalid Store. Store does not exist");
              //return res.status(400).json({ error: 'Invalid Store. Store does not exist' });
            }
          }
          
          //         if (is_available !== undefined && typeof is_available !== 'boolean') {
          //   return res.status(400).json({ message: 'Invalid value for is_available' });
          // }
          // const isAvailableValue = is_available !== undefined ? is_available : true;



          if( bookDataFromBody.author){
          if ( !isValidName(bookDataFromBody.author)) {
            validationErrors.push('Invalid author name' );
          }
        }

        if(bookDataFromBody.title)
          {      
          if (!isValidBookTitle(bookDataFromBody.title) ) {
            // return res.status(400).json({ error: 'Invalid book title' });
            validationErrors.push('Invalid book title');
          }
        }

        if (req.body.isbn) {
          try {
              const existingIsbnBook = await db('books').where('isbn', req.body.isbn).first();
              if (existingIsbnBook) {
                  validationErrors.push('ISBN already exists');
              } else if (!isValidISBN(req.body.isbn)) {
                  return res.status(400).json({ error: 'Invalid ISBN format' });
              }
          } catch (error) {
              console.error('Error checking ISBN uniqueness:', error);
              validationErrors.push('Error checking ISBN uniqueness');
              // Handle the error based on your application's needs
          }
      }
      
      

          
        if(req.body.price){
          if (!isValidPrice(req.body.price) ) {
            validationErrors.push("Invalid Price .  Price must be a number . Price must be greater than 0 and less than 10000 with only 4 decimal.")
          //   return res.status(400).json({ error: 'Invalid Price .  Price must be a number . Price must be greater than 0 and less than 10000 with only 4 decimal.' });
          // }
        }
      }

        
         
      
          // if (!isValidPublicationDate(publication_date)) {
          //   return res.status(400).json({ error: 'Invalid Date' });
          // }


  
  
  
  


    
    
    const validFields = ['id','title', 'author','isbn', 'publication_date', 'Category', 'price', 'Store', 'is_available', 'quantity', 'descrption'];
    const invalidFields = Object.keys(req.body).filter(field => !validFields.includes(field));
    
    if (invalidFields.length > 0) {
      //validationErrors.push(invalidFields);
      return res.status(400).json({ message : `Invalid fields :[${invalidFields.join(', ')}]` });
    }
    
    

    //const isbnFromBody = updatedFields.isbn;

      
    
    
    

    if (validationErrors.length > 0) {
      const errorMessage = "  " + validationErrors.join(', ') + "";
      const errorResponse = { "Validation errors:": [errorMessage] };
      return res.status(400).json(errorResponse);
  }
  

           
          console.log("entering update block")
          await db('books').where('id',bookDataFromBody.id )
          .update(req.body);
         
          const bookadded = await db('books').where('id', bookDataFromBody.id ).first();
          res.status(200).json({ message: 'book updated succesfully' ,bookadded});
        }
       
        else {
          const validationErrors= [];
      const { title, isbn, publication_date, author, Store, description, Category, price, is_available } = req.body;
  
      console.log(req.body);
      const validFields = ['id','title', 'author', 'isbn', 'publication_date', 'Category','price','Store','is_available','description']; // Add all valid fields

      const invalidFields = Object.keys(req.body).filter(field => !validFields.includes(field));

if (invalidFields.length > 0) {
  return res.status(400).json({ message: `Invalid fields: ${invalidFields.join(', ')}` });
}
      if (!req.body || Object.keys(req.body).length === 0) {
        return res.status(400).json({ error: 'Empty request body' });
      }
      if(isbn){
      const existingisbn = await db('books').where('isbn', req.body.isbn).first();
    if (existingisbn) {
      validationErrors.push('isbn no.  already exist' );
    }
      }
    const missingFields = [];

     if (!title) missingFields.push('title');
     if (!isbn) missingFields.push('isbn');
     if (!publication_date) missingFields.push('publication_date');
     if (!author) missingFields.push('author');
     if (!Store) missingFields.push('Store');
     //if (!quantity) missingFields.push('quantity');
     if (!Category) missingFields.push('Category');
     if (!price) missingFields.push('price');

     if (missingFields.length > 0) {
        console.error('Missing fields:', missingFields);
        return res.status(400).json({ error: `Missing required fields: ${missingFields.join(', ')}` });
      }
  
      // if (!publication_date) {
      //   return res.status(400).json({ message: 'Date of publication is required' });
      // }
  
     
      if (is_available !== undefined && typeof is_available !== 'boolean') {
        validationErrors.push('Invalid value for is_available' );
      }
      const isAvailableValue = is_available !== undefined ? is_available : true;
  
      if (!isValidName(Category))  {
        validationErrors.push('Invalid Catgory name' );
      }
      if ( !isValidName(author) ) {
        validationErrors.push('Invalid Author name' );
      }
      
      if (!isValidBookTitle(title) ) {
        validationErrors.push( 'Invalid book title' );
      }
      if (!isValidISBN(isbn) ) {
        validationErrors.push( 'Invalid isbn or isbn can not be null' );
      }
      if (!isValidPrice(price) ) {
        validationErrors.push('Invalid price . price must be greater than 0 and less than 10000 with only 4 decimal.' );
      }
      const storeExists = await db('bookstore').where('store', Store).first();
  
      if (!storeExists) {
        validationErrors.push( 'Invalid Store. Store does not exist' );
      }
     
  
      if (!isValidPublicationDate(publication_date)) {
        validationErrors.push('Invalid Date' );
      }
      
      if (validationErrors.length > 0) {
        const errorMessage = "  " + validationErrors.join(', ') + "";
        const errorResponse = { "Validation errors:": [errorMessage] };
        return res.status(400).json(errorResponse);
    }
          console.log("entering insert this block")
          await db('books').insert({
              title: bookDataFromBody.title,
              isbn: bookDataFromBody.isbn,
              publication_date: bookDataFromBody.publication_date,
              author: bookDataFromBody.author,
              Store: bookDataFromBody.Store,
              description: bookDataFromBody.description,
      
              Category: bookDataFromBody.Category,
              price: bookDataFromBody.price,
              is_available: bookDataFromBody.isAvailableValue,
          });
         
          const bookadded = await db('books').where('title', bookDataFromBody.title).first();
          return res.status(200).json({ message: 'Added book successfully', bookadded });
        }
      }
        // Commit the transaction
        // await trx.commit();
    catch (error) {
      // Rollback the transaction in case of an error
      console.error('Error during upsert:', error);
      res.status(500).send('Internal Server Error');
    }
  });
//     try {
//       await db.transaction(async (trx) => {
//        // const existingBook = await trx('books').select('title').where('title', bookDataFromBody.title).first();
//        const existingBook = await db('books').select('id').where('id', bookDataFromBody.id).first();
//         if(!existingBook){
//            console.log('book does not exist.' );
//         }
//         //console.log(existingBook);
  
//         if (existingBook) {
//           // Book exists, update it
//           await trx('books')
//             //.where('title', bookDataFromBody.title)
//             .where('id', books.id)
//             .update({
//               //id:bookDataFromBody.id,
//               title: bookDataFromBody.title,
//               isbn: bookDataFromBody.isbn,
//               publication_date: bookDataFromBody.publication_date,
//               author: bookDataFromBody.author,
//               Store: bookDataFromBody.Store,
//               description: bookDataFromBody.description,
//             //   quantity: bookDataFromBody.quantity,
//               Category: bookDataFromBody.Category,
//               price: bookDataFromBody.price,
//               is_available: bookDataFromBody.is_available,
//             });
//             res.json({ message: 'update operation completed successfully' });
//         } 
//         else {
//           // Book doesn't exist, insert it
//           await trx('books').insert(
//             {  
//               //id:bookDataFromBody.id,
//               title: bookDataFromBody.title,
//               isbn: bookDataFromBody.isbn,
//               publication_date: bookDataFromBody.publication_date,
//               author: bookDataFromBody.author,
//               Store: bookDataFromBody.Store,
//               description: bookDataFromBody.description,
      
//               Category: bookDataFromBody.Category,
//               price: bookDataFromBody.price,
//               is_available: bookDataFromBody.is_available,
//             }
//           );
//           //res.json({ message: 'insert operation completed successfully' });
//           const bookadded = await db('books').where('title', bookDataFromBody.title ).first();
//         res.json({ message: 'added book succesfully',bookadded });
//         }
//       });
  
      
//     } catch (error) {
//       console.error('Error performing upsert:', error);
//       res.status(500).json({ message: 'Internal Server Error' });
//     }
//   });
  // app.listen(port, () => {
  //   console.log(`Server is running on port ${port}`);
  // });

  module.exports = router;